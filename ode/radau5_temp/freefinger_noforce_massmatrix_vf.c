/*  Vector field function and events for Radau integrator.
  This code was automatically generated by PyDSTool, but may be modified by hand. */

#include <math.h>
#include <Python.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "events.h"
#include "maxmin.h"
#include "signum.h"
#include "vfield.h"

extern double *gICs;
extern double **gBds;
extern double globalt0;

static double pi = 3.1415926535897931;

double signum(double x)
{
  if (x<0) {
    return -1;
  }
  else if (x==0) {
    return 0;
  }
  else if (x>0) {
    return 1;
  }
  else {
    /* must be that x is Not-a-Number */
    return x;
  }
}


/* Variable, aux variable, parameter, and input definitions: */ 
#define F	p_[0]
#define I2	p_[1]
#define I3	p_[2]
#define b1	p_[3]
#define b2	p_[4]
#define b3	p_[5]
#define eta	p_[6]
#define g	p_[7]
#define i1	p_[8]
#define k1	p_[9]
#define k2	p_[10]
#define k3	p_[11]
#define l1	p_[12]
#define l2	p_[13]
#define l3	p_[14]
#define m1	p_[15]
#define m2	p_[16]
#define m3	p_[17]
#define phi1ref	p_[18]
#define phi2ref	p_[19]
#define phi3ref	p_[20]
#define tau1	p_[21]
#define tau2	p_[22]
#define tau3	p_[23]
#define phi1	Y_[0]
#define phi1dot	Y_[1]
#define phi2	Y_[2]
#define phi2dot	Y_[3]
#define phi3	Y_[4]
#define phi3dot	Y_[5]


double __maxof2(double e1_, double e2_, double *p_, double *wk_, double *xv_);
double __maxof3(double e1_, double e2_, double e3_, double *p_, double *wk_, double *xv_);
double __maxof4(double e1_, double e2_, double e3_, double e4_, double *p_, double *wk_, double *xv_);
double __minof2(double e1_, double e2_, double *p_, double *wk_, double *xv_);
double __minof3(double e1_, double e2_, double e3_, double *p_, double *wk_, double *xv_);
double __minof4(double e1_, double e2_, double e3_, double e4_, double *p_, double *wk_, double *xv_);
double __rhs_if(int cond_, double e1_, double e2_, double *p_, double *wk_, double *xv_);
double getbound(char *name, int which_bd, double *p_, double *wk_, double *xv_);
double globalindepvar(double t, double *p_, double *wk_, double *xv_);
double initcond(char *varname, double *p_, double *wk_, double *xv_);
int getindex(char *name, double *p_, double *wk_, double *xv_);
int heav(double x_, double *p_, double *wk_, double *xv_);
void massMatrix(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double **f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_);

int N_EVENTS = 0;
void assignEvents(EvFunType *events){
 
}

void auxvars(unsigned, unsigned, double, double*, double*, double*, unsigned, double*, unsigned, double*);
void jacobian(unsigned, unsigned, double, double*, double*, double**, unsigned, double*, unsigned, double*);
void jacobianParam(unsigned, unsigned, double, double*, double*, double**, unsigned, double*, unsigned, double*);
int N_AUXVARS = 0;


int N_EXTINPUTS = 0;


void vfieldfunc(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double *f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_){
/* reused term definitions */
double c1 = cos(phi1);
double c12 = cos(phi1+phi2);
double c123 = cos(phi1+phi2+phi3);
double s2 = sin(phi2);
double s23 = sin(phi2+phi3);
double s3 = sin(phi3);

f_[0] = phi1dot;
f_[1] = l1*phi2dot*m2*l2*s2*phi1dot-b1*phi1dot+1/2*m1*g*l1*c1+1/2*m2*g*l2*c12+1/2*m3*g*l3*c123-k1*phi1+k1*phi1ref+m2*g*l1*c1+m3*g*l1*c1+m3*g*l2*c12+m3*l3*phi3dot*l2*phi1dot*s3+m3*l3*phi3dot*phi1dot*l1*s23+m3*l3*phi3dot*l2*phi2dot*s3+1/2*m3*l3*pow(phi3dot,2)*l1*s23+1/2*m3*l3*pow(phi3dot,2)*l2*s3+1/2*l1*pow(phi2dot,2)*m2*l2*s2+2*l1*phi2dot*m3*l2*phi1dot*s2+l1*pow(phi2dot,2)*m3*l2*s2+l1*phi2dot*m3*phi1dot*l3*s23+1/2*l1*pow(phi2dot,2)*m3*l3*s23+l1*phi2dot*m3*l3*phi3dot*s23;
f_[2] = phi2dot;
f_[3] = -b2*phi2dot-1/2*m2*l2*l1*s2*pow(phi1dot,2)-k2*phi2+k2*phi2ref+1/2*m2*g*l2*c12+1/2*m3*g*l3*c123+m3*g*l2*c12+m3*l3*phi3dot*l2*phi1dot*s3+m3*l3*phi3dot*l2*phi2dot*s3+1/2*m3*l3*pow(phi3dot,2)*l2*s3-m3*pow(phi1dot,2)*l1*l2*s2-1/2*m3*pow(phi1dot,2)*l1*l3*s23;
f_[4] = phi3dot;
f_[5] = -b3*phi3dot-m3*l3*l2*phi1dot*phi2dot*s3-1/2*m3*l3*l2*pow(phi2dot,2)*s3+1/2*m3*g*l3*c123-k3*phi3+k3*phi3ref-1/2*m3*pow(phi1dot,2)*l1*l3*s23-1/2*m3*l3*pow(phi1dot,2)*l2*s3;

}




double __maxof2(double e1_, double e2_, double *p_, double *wk_, double *xv_) {
if (e1_ > e2_) {return e1_;} else {return e2_;};
}


double __maxof3(double e1_, double e2_, double e3_, double *p_, double *wk_, double *xv_) {
double temp_;
if (e1_ > e2_) {temp_ = e1_;} else {temp_ = e2_;};
if (e3_ > temp_) {return e3_;} else {return temp_;};
}


double __maxof4(double e1_, double e2_, double e3_, double e4_, double *p_, double *wk_, double *xv_) {
double temp_;
if (e1_ > e2_) {temp_ = e1_;} else {temp_ = e2_;};
if (e3_ > temp_) {temp_ = e3_;};
if (e4_ > temp_) {return e4_;} else {return temp_;};
}


double __minof2(double e1_, double e2_, double *p_, double *wk_, double *xv_) {
if (e1_ < e2_) {return e1_;} else {return e2_;};
}


double __minof3(double e1_, double e2_, double e3_, double *p_, double *wk_, double *xv_) {
double temp_;
if (e1_ < e2_) {temp_ = e1_;} else {temp_ = e2_;};
if (e3_ < temp_) {return e3_;} else {return temp_;};
}


double __minof4(double e1_, double e2_, double e3_, double e4_, double *p_, double *wk_, double *xv_) {
double temp_;
if (e1_ < e2_) {temp_ = e1_;} else {temp_ = e2_;};
if (e3_ < temp_) {temp_ = e3_;};
if (e4_ < temp_) {return e4_;} else {return temp_;};
}


double __rhs_if(int cond_, double e1_, double e2_, double *p_, double *wk_, double *xv_) {
  if (cond_) {return e1_;} else {return e2_;};
}


double getbound(char *name, int which_bd, double *p_, double *wk_, double *xv_) {
  return gBds[which_bd][getindex(name, p_, wk_, xv_)];
}


double globalindepvar(double t, double *p_, double *wk_, double *xv_) {
  return globalt0+t;
}


double initcond(char *varname, double *p_, double *wk_, double *xv_) {

  if (strcmp(varname, "phi1")==0)
	return gICs[0];
  else if (strcmp(varname, "phi1dot")==0)
	return gICs[1];
  else if (strcmp(varname, "phi2")==0)
	return gICs[2];
  else if (strcmp(varname, "phi2dot")==0)
	return gICs[3];
  else if (strcmp(varname, "phi3")==0)
	return gICs[4];
  else if (strcmp(varname, "phi3dot")==0)
	return gICs[5];
  else {
	fprintf(stderr, "Invalid variable name %s for initcond call\n", varname);
	return 0.0/0.0;
	}
}


int getindex(char *name, double *p_, double *wk_, double *xv_) {

  if (strcmp(name, "phi1")==0)
	return 0;
  else if (strcmp(name, "phi1dot")==0)
	return 1;
  else if (strcmp(name, "phi2")==0)
	return 2;
  else if (strcmp(name, "phi2dot")==0)
	return 3;
  else if (strcmp(name, "phi3")==0)
	return 4;
  else if (strcmp(name, "phi3dot")==0)
	return 5;
  else if (strcmp(name, "F")==0)
	return 6;
  else if (strcmp(name, "I2")==0)
	return 7;
  else if (strcmp(name, "I3")==0)
	return 8;
  else if (strcmp(name, "b1")==0)
	return 9;
  else if (strcmp(name, "b2")==0)
	return 10;
  else if (strcmp(name, "b3")==0)
	return 11;
  else if (strcmp(name, "eta")==0)
	return 12;
  else if (strcmp(name, "g")==0)
	return 13;
  else if (strcmp(name, "i1")==0)
	return 14;
  else if (strcmp(name, "k1")==0)
	return 15;
  else if (strcmp(name, "k2")==0)
	return 16;
  else if (strcmp(name, "k3")==0)
	return 17;
  else if (strcmp(name, "l1")==0)
	return 18;
  else if (strcmp(name, "l2")==0)
	return 19;
  else if (strcmp(name, "l3")==0)
	return 20;
  else if (strcmp(name, "m1")==0)
	return 21;
  else if (strcmp(name, "m2")==0)
	return 22;
  else if (strcmp(name, "m3")==0)
	return 23;
  else if (strcmp(name, "phi1ref")==0)
	return 24;
  else if (strcmp(name, "phi2ref")==0)
	return 25;
  else if (strcmp(name, "phi3ref")==0)
	return 26;
  else if (strcmp(name, "tau1")==0)
	return 27;
  else if (strcmp(name, "tau2")==0)
	return 28;
  else if (strcmp(name, "tau3")==0)
	return 29;
  else {
	fprintf(stderr, "Invalid name %s for getindex call\n", name);
	return 0.0/0.0;
	}
}


int heav(double x_, double *p_, double *wk_, double *xv_) {
  if (x_>0.0) {return 1;} else {return 0;}
}


void massMatrix(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double **f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_) {


/* reused term definitions */
double c2 = cos(phi2);
double c23 = cos(phi2+phi3);
double c3 = cos(phi3);
double mterm2 = 1/4*m3*pow(l3,2)+1/2*m3*l3*l1*c23+1/2*m3*l2*l3*c3+I3;
double mterm3 = 1/4*m3*pow(l3,2)+1/2*m3*l2*l3*c3+I3;
double mterm1 = 1/4*m2*pow(l2,2)+1/4*m3*pow(l3,2)+m3*pow(l2,2)+1/2*m2*l2*l1*c2+m3*l2*l1*c2+m3*l2*l3*c3+1/2*m3*l3*l1*c23+I2+I3;

f_[0][0] = 1;
f_[0][1] = 0;
f_[0][2] = 0;
f_[0][3] = 0;
f_[0][4] = 0;
f_[0][5] = 0;
f_[1][0] = 0;
f_[1][1] = m2*l2*l1*c2+1/4*m2*pow(l2,2)+m2*pow(l1,2)+m3*pow(l1,2)+m3*pow(l2,2)+1/4*m3*pow(l3,2)+1/4*m1*pow(l1,2)+I1+I2+I3+2*m3*l2*l1*c2+m3*l3*l1*c23+m3*l2*l3*c3;
f_[1][2] = 0;
f_[1][3] = mterm1;
f_[1][4] = 0;
f_[1][5] = mterm2;
f_[2][0] = 0;
f_[2][1] = 0;
f_[2][2] = 1;
f_[2][3] = 0;
f_[2][4] = 0;
f_[2][5] = 0;
f_[3][0] = 0;
f_[3][1] = mterm1;
f_[3][2] = 0;
f_[3][3] = 1/4*m2*pow(l2,2)+1/4*m3*pow(l3,2)+m3*pow(l2,2)+m3*l2*l3*c3+I2+I3;
f_[3][4] = 0;
f_[3][5] = mterm3;
f_[4][0] = 0;
f_[4][1] = 0;
f_[4][2] = 0;
f_[4][3] = 0;
f_[4][4] = 1;
f_[4][5] = 0;
f_[5][0] = 0;
f_[5][1] = mterm2;
f_[5][2] = 0;
f_[5][3] = mterm3;
f_[5][4] = 0;
f_[5][5] = 1/4*m3*pow(l3,2)+I3;

 ;

}

void auxvars(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double *f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_){


}


void jacobian(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double **f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_) {
}

void jacobianParam(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double **f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_) {
}
